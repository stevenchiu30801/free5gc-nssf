/*
 * NSSF NS Selection
 *
 * NSSF Network Slice Selection Service
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package nssf

import (
    "encoding/json"
    "net/http"
    "strings"

    flog "../flog"
    . "../model"
)

// Title in Problem Details for NSSF HTTP APIs
const (
    INVALID_REQUEST = "Invalid request message framing"
    MALFORMED_REQUEST = "Malformed request syntax"
    UNSUPPORTED_RESOURCE = "Unsupported request resources"
)

// Variable related to the UE
var (
    isRoamer bool = false
    ueAccessType AccessType = IS_3_GPP_ACCESS
)

// Parse NSSelectionGet query parameter
func parseQueryParameter(r *http.Request) (p NsselectionQueryParameter, err error) {

    q := r.URL.Query()

    if q.Get("nf-type") != "" {
        p.NfType = new(NfType)
        *p.NfType = NfType(q.Get("nf-type"))
    }

    p.NfId = q.Get("nf-id")

    if q.Get("slice-info-request-for-registration") != "" {
        p.SliceInfoRequestForRegistration = new(SliceInfoForRegistration)
        err = json.NewDecoder(strings.NewReader(q.Get("slice-info-request-for-registration"))).Decode(p.SliceInfoRequestForRegistration)
        if err != nil {
            return
        }
    }

    if q.Get("slice-info-request-for-pdu-session") != "" {
        p.SliceInfoRequestForPduSession = new(SliceInfoForPduSession)
        err = json.NewDecoder(strings.NewReader(q.Get("slice-info-request-for-pdu-session"))).Decode(p.SliceInfoRequestForPduSession)
        if err != nil {
            return
        }
    }

    if q.Get("home-plmn-id") != "" {
        p.HomePlmnId = new(PlmnId)
        err = json.NewDecoder(strings.NewReader(q.Get("home-plmn-id"))).Decode(p.HomePlmnId)
        if err != nil {
            return
        }
    }

    if q.Get("tai") != "" {
        p.Tai = new(Tai)
        err = json.NewDecoder(strings.NewReader(q.Get("tai"))).Decode(p.Tai)
        if err != nil {
            return
        }
    }

    if q.Get("supported-features") != "" {
        p.SupportedFeatures = q.Get("supported-features")
    }

    return
}

// NSSelectionGet - Retrieve the Network Slice Selection Information
func NSSelectionGet(w http.ResponseWriter, r *http.Request) {

    flog.Info("NSSelectionGet - Request received")

    var (
        isValidRequest bool = true
        status int
        a AuthorizedNetworkSliceInfo
        d ProblemDetails
    )

    // Parse query parameter
    p, err := parseQueryParameter(r)
    if err != nil {
        problemDetail := err.Error()
        flog.Info("NSSelectionGet - %s", problemDetail)
        status = http.StatusBadRequest
        d = ProblemDetails {
            Title: MALFORMED_REQUEST,
            Status: http.StatusBadRequest,
            Detail: problemDetail,
        }
        isValidRequest = false
    }

    // Check data integrity
    err = p.CheckIntegrity()
    if err != nil {
        problemDetail := err.Error()
        flog.Info("NSSelectionGet - %s", problemDetail)
        status = http.StatusBadRequest
        d = ProblemDetails {
            Title: INVALID_REQUEST,
            Status: http.StatusBadRequest,
            Detail: problemDetail,
        }
        isValidRequest = false
    }

    if isValidRequest == true {
        // Determine whether UE is a roamer to the serving PLMN with the existence of the IE `home-plmn-id`
        if p.HomePlmnId != nil {
            isRoamer = true
        }
        // Determine Access Type of UE with the existence of the IE `tai`
        if p.Tai == nil {
            ueAccessType = NON_3_GPP_ACCESS
        }

        if p.SliceInfoRequestForRegistration != nil && p.SliceInfoRequestForPduSession == nil {
            // Network slice information is requested during the Registration procedure
            status = nsselectionForRegistration(p, &a, &d)
        } else if p.SliceInfoRequestForRegistration == nil && p.SliceInfoRequestForPduSession != nil {
            // Network slice information is requested during the PDU session establishment procedure
            status = nsselectionForPduSession(p, &a, &d)
        } else if p.SliceInfoRequestForRegistration != nil && p.SliceInfoRequestForPduSession != nil {
            problemDetail := "Slice info requests for both registration and PDU session are provided simultaneously"
            flog.Info("NSSelectionGet - %s", problemDetail)
            status = http.StatusBadRequest
            d = ProblemDetails {
                Title: INVALID_REQUEST,
                Status: http.StatusBadRequest,
                Detail: problemDetail,
            }
        } else {
            problemDetail := "None of slice info request for registration or PDU session is provided"
            flog.Info("NSSelectionGet - %s", problemDetail)
            status = http.StatusBadRequest
            d = ProblemDetails {
                Title: INVALID_REQUEST,
                Status: http.StatusBadRequest,
                Detail: problemDetail,
            }
        }
    }

    // Set response
    w.Header().Set("Content-Type", "application/json; charset=UTF-8")

    w.WriteHeader(status)
    switch status {
        case http.StatusOK:
            json.NewEncoder(w).Encode(&a)
            flog.Info("NSSelectionGet - Response code 200 OK")
        case http.StatusBadRequest:
            json.NewEncoder(w).Encode(&d)
            flog.Info("NSSelectionGet - Response code 400 Bad Request")
        case http.StatusForbidden:
            json.NewEncoder(w).Encode(&d)
            flog.Info("NSSelectionGet - Response code 403 Forbidden")
        default:
            flog.Warn("NSSelectionGet - Unknown response code")
    }
}
