/*
 * NSSF NS Selection
 *
 * NSSF Network Slice Selection Service
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package nssf

import (
    "encoding/json"
    "net/http"
    "strings"

    flog "../flog"
    . "../model"
)

// Parse NSSelectionGet query parameter
func parseQueryParameter(r *http.Request) (p NsselectionQueryParameter) {

    q := r.URL.Query()

    p.NfType = q.Get("nf-type")
    p.NfId = q.Get("nf-id")

    if q.Get("slice-info-request-for-registration") != "" {
        p.SliceInfoRequestForRegistration = new(SliceInfoForRegistration)
        json.NewDecoder(strings.NewReader(q.Get("slice-info-request-for-registration"))).Decode(p.SliceInfoRequestForRegistration)
    }

    if q.Get("slice-info-request-for-pdu-session") != "" {
        p.SliceInfoRequestForPduSession = new(SliceInfoForPduSession)
        json.NewDecoder(strings.NewReader(q.Get("slice-info-request-for-pdu-session"))).Decode(p.SliceInfoRequestForRegistration)
    }

    if q.Get("home-plmn-id") != "" {
        p.HomePlmnId = new(PlmnId)
        json.NewDecoder(strings.NewReader(q.Get("home-plmn-id"))).Decode(p.HomePlmnId)
    }

    if q.Get("tai") != "" {
        p.Tai = new(Tai)
        json.NewDecoder(strings.NewReader(q.Get("tai"))).Decode(p.Tai)
    }

    p.SupportedFeatures = q.Get("supported-features")

    return
}

// NSSelectionGet - Retrieve the Network Slice Selection Information
func NSSelectionGet(w http.ResponseWriter, r *http.Request) {

    flog.Info("NSSelectionGet - Request received")

    var (
        status int
        a AuthorizedNetworkSliceInfo
        d ProblemDetails
    )

    p := parseQueryParameter(r)

    // Set response
    w.Header().Set("Content-Type", "application/json; charset=UTF-8")

    if p.SliceInfoRequestForRegistration != nil && p.SliceInfoRequestForPduSession == nil {
        status = nsselectionForRegistration(p, &a, &d)
    } else if p.SliceInfoRequestForRegistration == nil && p.SliceInfoRequestForPduSession != nil {
        status = nsselectionForPduSession(p, &a, &d)
    } else if p.SliceInfoRequestForRegistration != nil && p.SliceInfoRequestForPduSession != nil {
        problemTitle := "Simultaneous slice info requests for both registration and PDU session"
        flog.Info("NSSelectionGet - %s", problemTitle)
        status = http.StatusBadRequest
        d = ProblemDetails {
            Title: problemTitle,
            Status: http.StatusBadRequest,
        }
    } else {
        problemTitle := "None of slice info requests for registration and PDU session"
        flog.Info("NSSelectionGet - %s", problemTitle)
        status = http.StatusBadRequest
        d = ProblemDetails {
            Title: problemTitle,
            Status: http.StatusBadRequest,
        }
    }

    w.WriteHeader(status)
    switch status {
        case http.StatusOK:
            json.NewEncoder(w).Encode(&a)
            flog.Info("NSSelectionGet - Response code 200 OK")
        case http.StatusBadRequest:
            json.NewEncoder(w).Encode(&d)
            flog.Info("NSSelectionGet - Response code 400 Bad Request")
        case http.StatusForbidden:
            json.NewEncoder(w).Encode(&d)
            flog.Info("NSSelectionGet - Response code 403 Forbidden")
        default:
            flog.Warn("NSSelectionGet - Unknown response code")
    }
}
